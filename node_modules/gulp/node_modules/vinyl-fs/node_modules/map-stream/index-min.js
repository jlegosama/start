//filter will reemit the data if cb(err,pass) pass is truthy
// reduce is more tricky
// maybe we want to group the reductions or emit progress updates occasionally
// the most basic reduce just emits one 'data' event after it has recieved 'end'
var Stream=require("stream").Stream;module.exports=function(e,t){function p(e,t){var r=f+1;if(t===r){e!==undefined&&n.emit.apply(n,["data",e]);f++;r++}else h[t]=e;if(h.hasOwnProperty(r)){var a=h[r];delete h[r];return p(a,r)}s++;if(i===s){u&&(u=!1,n.emit("drain"));o&&m()}}function d(e,t,i){if(a)return;l=!0;(!e||r.opts.failures)&&p(t,i);e&&n.emit.apply(n,[c,e]);l=!1}function v(t,n,r){return e.call(null,t,function(e,t){r(e,t,n)})}function m(e){o=!0;n.writable=!1;if(e!==undefined)return p(e,i);i==s&&(n.readable=!1,n.emit("end"),n.destroy())}var n=new Stream,r=this,i=0,s=0,o=!1,u=!1,a=!1,f=0,l=!1;this.opts=t||{};var c=this.opts.failures?"failure":"error",h={};n.writable=!0;n.readable=!0;n.write=function(e){if(o)throw new Error("map stream is not writable");l=!1;i++;try{var t=v(e,i,d);u=t===!1;return!u}catch(n){if(l)throw n;d(n);return!u}};n.end=function(e){if(o)return;m()};n.destroy=function(){o=a=!0;n.writable=n.readable=u=!1;process.nextTick(function(){n.emit("close")})};n.pause=function(){u=!0};n.resume=function(){u=!1};return n};